package org.grails.wiki

import org.jsoup.Jsoup
import org.jsoup.nodes.*
import org.jsoup.helper.StringUtil

/**
 * <h2>Shortens the content of HTML while maintaining the integrity of the markup.</h2>
 *
 * <p>The basic idea is that the developer wants to limit the displayed text content
 * of some HTML fragment, such as the content generated by the wiki engine. The
 * problem is that the text content may be embedded in all sorts of markup, as you
 * would expect with HTML. Simply cutting the HTML text off at the max limit won't
 * work because you might end up with all markup and no text. Nor can you iterate
 * through the text content and delete everything after the point where you hit the
 * max limit specified. If you do, you might end up with hanging list items, anchors,
 * or anything else.</p>
 *
 * <p>To solve this problem, this class uses {@link jsoup http://jsoup.org/} to parse
 * the HTML. It then iterates through the text content until it finds the point at
 * which the max limit is reached. It then starts removing all child and subsequent
 * sibling nodes, before getting jsoup to serialise the DOM back into a string with
 * markup</p>
 *
 * <p>Of course, all these processing does not come cheap, so it's recommended that
 * you cache the results if you're planning on shortening the same text over and over
 * again, very frequently.</p>
 *
 * <p><strong>Warning</strong> This class is not thread-safe, but <em>is</em> cheap to
 * instantiate.</p>
 */
class HtmlShortener {

    String terminator = "..."

    // These fields are required to handle the special case where the max
    // character limit is reached at an element boundary.
    private requiresTermination
    private terminated

    /**
     * Shortens the given HTML so that the displayed text content does not
     * exceed to given limit. If the HTML content is {@code null} or an empty
     * string, then this returns an empty string. If the text content does
     * exceed the given limit, then the resulting string is limited to that
     * length and the {@link #terminator} is appended. Otherwise the content
     * is returned unchanged.
     */
    def shorten(String htmlText, int maxLength) {
        if (!htmlText) return ""
        if (htmlText.size() <= maxLength) return htmlText

        // Disable pretty printing after parsing the HTML, otherwise the
        // html() method will add indentation, etc.
        def doc = Jsoup.parseBodyFragment(htmlText)
        doc.outputSettings().prettyPrint(false)

        // Modify the DOM in-place, remove any extra content and nodes after
        // we reach 'maxLength' characters.
        processNode doc.body(), maxLength

        // If the max character limit was reach in the middle of a text node,
        // then the terminator will already have been added. If not, then it
        // needs adding now (assuming the content was shortened).
        if (requiresTermination && !terminated) {
            doc.body().appendChild(new TextNode(terminator, null))
        }

        // Return the serialised DOM, excluding the <body> tags.
        return doc.body().html()
    }

    private processNode(Element element, int maxLength) {
        // We'll potentially be removing nodes while iterating over the
        // children, so make sure we iterate over a copy. Otherwise we get
        // the dread ConcurrentModificationException.
        def children = new ArrayList(element.childNodes())
        def charsLeft = maxLength

        def prevNode

        for (node in children) {
            if (!charsLeft) {
                // If we have already processed maxLength characters, then
                // we can start removing subsequent nodes, be they children
                // or siblings. This happens recursively.
                node.remove()

                // If we're removing nodes, then we need to append a terminator
                // as the content is being shortened.
                requiresTermination = true
            }
            else {
                // Still haven't reached the limit on text characters, so
                // process this child node. Typically this is either another
                // element or a text node.
                charsLeft = processNode(node, charsLeft)
            }

            prevNode = node
        }

        return charsLeft
    }

    private processNode(TextNode node, int maxLength) {
        def text = node.text()
        if (text.size() <= maxLength) {
            // If we're still within the max limit, there's no need to update
            // the content of this node. Just return how many characters are
            // left to process.
            return maxLength - text.size()
        }
        else {
            // The max limit is hit somewhere in the middle of this node, so
            // shorten its content and append the terminator.
            node.text(text[0..<maxLength] + terminator)
            terminated = true
            return 0
        }
    }

    // Ignore these types or node as they are irrelevant (for now).
    private processNode(Comment node, int maxLength) { return null }
    private processNode(DataNode node, int maxLength) { return null }
    private processNode(DocumentType node, int maxLength) { return null }
    private processNode(XmlDeclaration node, int maxLength) { return null }
}
